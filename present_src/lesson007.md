---
marp: true
---

<style>
.columns {
  display: flex;
  gap: 50px;
  align-items: center;
}
.columns img {
  width: 300px;
  height: auto;
}
.columns .text {
  flex: 1;
}
</style>

# Повторение

## Ввод-вывод
## Условия - простые и сложные
## Логические значения
## Циклы
## Списки

---

# Изучаем язык Python
## Занятие 7 - Функции

---

Функции представляют собой готовые блоки кода для выполнения некоторой задачи. Некоторым функциям для выполнения своих операций необходимы дополнительные данные, которые должны передаваться им при вызове. Такие данные называются аргументами. Чтобы передать их функции, заключите их значения, разделенные запятыми, в круглые скобки после имени функции.

```python
print("Hello World")
```

здесь print — имя функции, а "Hello World" — аргумент.

---

Некоторые функции могут возвращать результат после выполнения своих задач. В данном примере функция replace() вернет "Hello Universe", которая присваивается переменной newString. 

```python
newString = "Hello World".replace("World", "Universe")
```

где replace — имя функции, а "World" и "Universe" — аргументы. Строка перед точкой (например, "Hello World") — та строка, с которой будет выполняться операция. Таким образом, "Hello World" превратится в "Hello Universe".

```python
print(newString) # Hello Universe
```

---

В языке Python можно определять собственные функции и повторно использовать их в программах. Синтаксис определения функции выглядит так:

```python
def functionName(список параметров):
 код операций, выполняемых функцией
 return [выражение]
```

В определении задействованы два ключевых слова: def и return. Ключевое слово def сообщает программе, что код с отступом, который начинается в следующей строке и идет далее, является частью функции. Ключевое слово return возвращает ответ из функции. Функция может содержать более одной команды return. 

---

## Борьба со сложностью . Декомпозиция задач.

Определим свою первую функцию. Допустим, вы хотите
узнать, является ли заданное число простым. В следующем определении функции используется оператор вычисления остатка (%), который был описан в разделе 3.4,
а также цикл for и команда if из главы 6:
def checkIfPrime (numberToCheck):
 for x in range(2, numberToCheck):
 if (numberToCheck%x == 0):
 return False
 return True
7.3. Область видимости переменных  83
Эта функция использует один параметр с именем numberToCheck. Параметры — переменные, которые используются для хранения аргументов, передаваемых функции.
В строках 2 и 3 в цикле for параметр numberToCheck
делится на все числа от 2 до numberToCheck - 1, после
чего программа проверяет, равен ли остаток нулю. Если
остаток равен нулю, то numberToCheck не является простым числом. Строка 4 возвращает False, и функция
возвращает управление.
Если к последней итерации цикла ни при одном делении
не будет получен нулевой остаток, функция достигает
строки 5 и возвращает True. После этого функция возвращает управление.
Чтобы использовать эту функцию, мы вводим вызов
checkIfPrime(13) и присваиваем ее переменной:
answer = checkIfPrime(13)
Здесь число 13 передается как аргумент и сохраняется в параметре numberToCheck. Затем цикл for проверяет, является ли число numberToCheck простым, и возвращает True или
False. Чтобы вывести ответ, введите команду print(answer). Как и следовало ожидать, выводится результат True.
7.3. ОБЛАСТЬ ВИДИМОСТИ
ПЕРЕМЕННЫХ
При определении функций очень важно понимать концепцию области видимости переменных. Переменные, опре-
84  Глава 7. Функции и модули
деленные внутри функции, отличаются от переменных,
определенных вне ее. Существуют два основных различия.
Во-первых, любая переменная, объявленная внутри функции, доступна только в этой функции. Такие переменные
называются локальными. Любая переменная, объявленная
за пределами функции, называется глобальной; такие
переменные доступны в любой точке программы.
Чтобы понять, чем глобальные переменные отличаются
от локальных, попробуйте выполнить следующий код:
message1 = "Global Variable"
def myFunction():
 print("\nINSIDE THE FUNCTION")
 # Глобальные переменные доступны внутри функции
 print (message1)
 # Объявление локальной переменной
 message2 = "Local Variable"
 print (message2)
'''
Вызов функции
Функция myFunction() не имеет параметров,
поэтому при вызове этой функции
используется пара круглых скобок.
'''
myFunction()
print("\nOUTSIDE THE FUNCTION")
# Глобальные переменные доступны за пределами функции
print (message1)
# Локальные переменные НЕДОСТУПНЫ за пределами функции
print (message2)
7.3. Область видимости переменных  85
Запустив программу, вы получите следующий результат:
INSIDE THE FUNCTION
Global Variable
Local Variable
OUTSIDE THE FUNCTION
Global Variable
NameError: name 'message2' is not defined
В приведенном фрагменте message1 — глобальная переменная, а message2 — локальная переменная, объявленная внутри функции myFunction(). Внутри функции
доступны как локальные, так и глобальные переменные.
За пределами функции локальная переменная message2
становится недоступной. При попытке обращения к ней
за пределами функции происходит ошибка NameError.
Второе, что нужно знать об области видимости переменных — если имя локальной переменной совпадает
с именем глобальной переменной, весь код внутри
функции будет работать с локальной переменной.
Весь код за пределами функции будет обращаться
к глобальной переменной. Попробуйте выполнить следующий код:
message1 = "Global Variable (shares same name as
 a local variable)"
def myFunction():
 message1 = "Local Variable (shares same name as
 a global variable)"
 print("\nINSIDE THE FUNCTION")
86  Глава 7. Функции и модули
 print (message1)
# Calling the function
myFunction()
# Printing message1 OUTSIDE the function
print ("\nOUTSIDE THE FUNCTION")
print (message1)
Результат выглядит так:
INSIDE THE FUNCTION
Local Variable (shares same name as a global variable)
OUTSIDE THE FUNCTION
Global Variable (shares same name as a local variable)
Когда мы выводим message1 внутри функции, выводится
строка "Local Variable (shares same name as a global
variable)", потому что выводится локальная переменная. При выводе за пределами функции программа обращается к глобальной переменной, поэтому выводится
строка "Global Variable (shares same name as a local
variable)".

# Изучаем язык Python
## Занятие 5 - Контейнерные типы данных - Списки

---

Чтобы не хранить данные как отдельные переменные, их можно хранить в виде списка. 

Например, вам в программе нужно сохранить возраст пяти пользователей. Чтобы не хранить их как user1Age, user2Age,user3Age, user4Age и user5Age, имеет смысл хранить их в виде списка.

При объявлении списка используются квадратные скобки []. Значения разделяются запятой.

Пример:
```python
usersAges = [21, 22, 23, 24, 25]
```

---

Значения в списке доступны по индексам, а индексы всегда начинаются с НУЛЯ, а не с единицы. Это обычная практика почти во всех языках программирования, например C и Java. Таким образом, индекс первого значения — 0, следующего — 1 и т. д. Например, 

```python
print(usersAges [0])  # 21 
print(usersAges [1])  # 22
```

Можно обращаться к значениям списка в обратном порядке. Последний элемент в списке имеет индекс –1, предпоследний — индекс –2 и т. д. Следовательно, 

```python
print(userAges[-1]) # 25
print(userAges[-2]) # 24
```

---

Теперь можно понять, почему так странно работает функция range(). Это сделано для удобства формирования индексов. Например, последовательность, генерируемая функцией range(5) соответствует индексам списка из пяти элементов.

```python
print(range(5)) # [0,1,2,3,4]
for i in range(5):
  print(usersAges[i])
```

Но обычно, если нужно перебрать элементы списка - функция range() не нужна.

```python
for userAge in usersAges:
  print(userAge)
```

---

Также функция print понимает списки напрямую.

```python
print(usersAges) # [21,22,23,24,25]
```

Или 

```python
print(*usersAges) # 21 22 23 24 25
```

---

Можно объявить пустой список без присвоения начальных значений. 

```python
usersAges2 = []. 
```

Чтобы добавить элементы в список, используйте метод append().

```python
usersAges2.append(51) 
usersAges2.append(56) 
usersAges2.append(60) 
usersAges2.append(35) 
```

Выводим список на экран

```python
print(usersAges2) # 51 56 60 35
```

---

Список или его часть можно назначить переменной. 

```python
list1 = usersAges
print(list1) # 21 22 23 24 25
list2 = usersAges[2:4] 
print(list2) # 22 23  - 2-ой и 3-й элемент
list3 = usersAges[1:5:2] 
print(list2) # 22 24  - 2-ой и 4-й элемент
```

Запись 2:4 называется срезом или слайсом. Когда мы используем срез в Python, включается элемент начального индекса, но всегда исключается элемент в конце, как в функции range().

Запись среза может включать третье число — шаг. Если
написать userAge4 = userAge [1:5:2], то получится подсписок, состоящий 
из каждого второго числа от индекса 1 до индекса 5 – 1

---

Элементы в списке можно изменять, по аналогии с обычными переменными

```python
usersAges[1] = 5
print(usersAges)  # [21, 5, 23, 24, 25]
```

Чтобы добавить элементы, используется функция append().

```python
usersAges.append (99)
print(usersAges)  # [21, 5, 23, 24, 25, 99]
```

Чтобы удалить элементы, используется синтаксис del.

```python
del userAge [2] 
print(usersAges)  # [21, 5, 24, 25, 99]
# третий элемент удален
```

---

Проверить, есть ли элемент в списке можно с помощью операторов "in"

```python
myList = [1, 2, 3, 4, 5]
item = 3
if item in myList:
    print("Элемент",  item,  "есть в списке")
else:
    print("Элемент", item,  "отсутствует в списке")
```

Обратная проверка - оператор "not in"

```python
myList = [1, 2, 3, 4, 5]
item = 10
if item not in myList:
    print("Элемент",  item,  "отсутствует в списке")
else:
    print("Элемент", item,  "есть в списке")
```

---

## Задача: список поэтов

1. Определите список сотоящий из поэтов золотого и серебряного века (через одного - золотой, серебряный, золотой, серебряный) в сумме не менее 6.
2. Добавьте с помощью append() советских поэтов или бардов (не менее 4).
3. Удалите с помощью del поэтов золотого века.
4. Выберите с помощью слайсов поэтов серебряного века.
5. Проверить, есть ли в списке Есенин
6. Выводите список на печать после каждой итерации.

